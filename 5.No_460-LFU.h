#include<unordered_map>
#include<list>
using namespace std;

struct Node {
	int key, val, freq;
	Node(int _key, int _val, int _freq) :key(_key), val(_val), freq(_freq) {}
};


//写法1：保存的是Node*
class LFUCache {
	int minfreq, capacity;
	unordered_map<int, list<Node*>::iterator> key_table;		//此处key_table中的value必须得是list<Node*>::iterator类型，因为用的stl中的list.erase
	unordered_map<int, list<Node*>> freq_table;					//freq_table中的每个list，新来的节点会被放在链表头部
public:
	LFUCache(int _capacity) :minfreq(0), capacity(_capacity) {
		this->key_table.clear();
		this->freq_table.clear();
	}

	int get(int key) {
		if (key_table.find(key) != key_table.end()) {
			list<Node*>::iterator it_node = key_table[key];		//注意此处it_node是迭代器，不是Node*
			Node* node = *it_node;								//node才是
			int tmp_freq = node->freq;
			node->freq++;
			//更新freq_table
			freq_table[tmp_freq].erase(it_node);
			freq_table[tmp_freq + 1].emplace_front(node);		//往前插入
			//更新minfreq
			if (freq_table[tmp_freq].size() == 0) {
				freq_table.erase(tmp_freq);
				if (minfreq == tmp_freq) minfreq++;
			}
			//更新key_table，保存刚刚存储的迭代器
			key_table[key] = freq_table[tmp_freq + 1].begin();	//此时的begin就是刚刚插入的节点，也是为什么要将新节点放在头部的原因
			return node->val;
		}
		return -1;
	}

	void put(int key, int value) {
		//非常重要的一句，否则会导致 int minKey = freq_table[minfreq].back()->key; 报错
		if (capacity == 0) return;

		if (key_table.find(key) != key_table.end()) {
			list<Node*>::iterator it_node = key_table[key];
			Node* node = *it_node;
			int tmp_freq = node->freq;
			node->freq++;
			node->val = value;
			freq_table[tmp_freq].erase(it_node);
			freq_table[tmp_freq + 1].emplace_front(node);
			if (freq_table[tmp_freq].size() == 0) {
				freq_table.erase(tmp_freq);
				if (minfreq == tmp_freq) minfreq++;
			}
			key_table[key] = freq_table[tmp_freq + 1].begin();
		}
		//需要插入新的节点
		else {	
			//当前已满，需要删除freq最小且最靠后的节点
			if (key_table.size() == capacity) {
				int minKey = freq_table[minfreq].back()->key;
				key_table.erase(minKey);
				freq_table[minfreq].pop_back();
				if (freq_table[minfreq].size() == 0) freq_table.erase(minfreq);
			}
			//插入新节点，freq一定是1
			Node* node = new Node(key, value, 1);
			freq_table[1].emplace_front(node);
			key_table[key] = freq_table[1].begin();
			minfreq = 1;
		}
	}
};


//写法2：保存的是Node
class LFUCache {
	int minfreq, capacity;
	unordered_map<int, list<Node>::iterator> key_table;
	unordered_map<int, list<Node>> freq_table;
public:
	LFUCache(int _capacity) {
		minfreq = 0;
		capacity = _capacity;
		key_table.clear();
		freq_table.clear();
	}

	int get(int key) {
		if (capacity == 0) return -1;
		auto it = key_table.find(key);
		if (it == key_table.end()) return -1;
		list<Node>::iterator node = it->second;
		int val = node->val, freq = node->freq;
		freq_table[freq].erase(node);
		// 如果当前链表为空，我们需要在哈希表中删除，且更新minFreq
		if (freq_table[freq].size() == 0) {
			freq_table.erase(freq);
			if (minfreq == freq) minfreq += 1;
		}
		// 插入到 freq + 1 中
		freq_table[freq + 1].push_front(Node(key, val, freq + 1));
		key_table[key] = freq_table[freq + 1].begin();
		return val;
	}

	void put(int key, int value) {
		if (capacity == 0) return;
		auto it = key_table.find(key);
		if (it == key_table.end()) {
			// 缓存已满，需要进行删除操作
			if (key_table.size() == capacity) {
				// 通过 minFreq 拿到 freq_table[minFreq] 链表的末尾节点
				auto it2 = freq_table[minfreq].back();
				key_table.erase(it2.key);
				freq_table[minfreq].pop_back();
				if (freq_table[minfreq].size() == 0) {
					freq_table.erase(minfreq);
				}
			}
			freq_table[1].push_front(Node(key, value, 1));
			key_table[key] = freq_table[1].begin();
			minfreq = 1;
		}
		else {
			// 与 get 操作基本一致，除了需要更新缓存的值
			list<Node>::iterator node = it->second;
			int freq = node->freq;
			freq_table[freq].erase(node);
			if (freq_table[freq].size() == 0) {
				freq_table.erase(freq);
				if (minfreq == freq) minfreq += 1;
			}
			freq_table[freq + 1].push_front(Node(key, value, freq + 1));
			key_table[key] = freq_table[freq + 1].begin();
		}
	}
};